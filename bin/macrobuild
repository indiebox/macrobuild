#!/usr/bin/perl
#
# Build something.
#
# This file is part of macrobuild.
# (C) 2012-2015 Indie Computing Corp.
#
# macrobuild is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# macrobuild is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with macrobuild.  If not, see <http://www.gnu.org/licenses/>.
#

use strict;
use warnings;

use UBOS::Logging;
use Macrobuild::Settings;
use Macrobuild::TaskRun;

my @taskNames; # names of the tasks to run
my $verbose       = 0;
my $interactive   = 0;
my $listShortcuts = 0;
my $printVars     = 0;
my $dryRun        = 0;
my $help          = 0;
my $logconf       = undef;

my ( $sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst ) = gmtime( time() );
my $settings = new Macrobuild::Settings(
        'default',
        {
            'tstamp' => ( sprintf "%.4d%.2d%.2d-%.2d%.2d%.2d", ($year+1900), ( $mon+1 ), $mday, $hour, $min, $sec )
        } );

$settings->addDefaultSettingsFrom(
    'local.pl',
    'settings.pl' );

my $err = $settings->addArgumentsFrom(
        \@ARGV,
        \@taskNames,
        \$interactive,
        \$verbose,
        \$help,
        \$listShortcuts,
        \$printVars,
        \$dryRun,
        \$logconf );

if( $err ) {
    if( $err == 1 ) {
        synopsisHelpQuit();
    } else {
        error( $err );
        exit 1;
    }
}

if( $help ) {
    synopsisHelpQuit( 1 );
}
if( !$listShortcuts && !$printVars && !@taskNames ) {
    synopsisHelpQuit();
}
if( $listShortcuts && $printVars ) {
    synopsisHelpQuit();
}

my $shortcuts = _determineEffectiveShortcuts( $settings->getAllVariableValues( 'shortcuts', {} ) );

if( $listShortcuts ) {
    if( keys %$shortcuts ) {
        use IO::Handle;
        STDOUT->autoflush; # make sure it appears before subroutine bails out in case of error

        if( $verbose ) {
            my $max = 8;
            foreach my $short ( keys %$shortcuts ) {
                if( length( $short ) > $max ) {
                    $max = length( $short );
                }
            }
            foreach my $short ( sort keys %$shortcuts ) {
                my $long = $shortcuts->{$short};
                if( ref( $long ) eq 'ARRAY' ) {
                    $long = join( ' ', @$long );
                }
                printf "%-" . $max . "s => %s\n", $short, $long;
            }
        } else {
            foreach my $short ( sort keys %$shortcuts ) {
                print "$short\n";
            }
        }
    } else {
        print "No short task names defined.\n";
    }
    exit 0;
}
if( $printVars ) {
    my $vars = $settings->getAllVariables();
    my $max = length( '(overridden)' ) + 2;
    foreach my $key ( keys %$vars ) {
        if( length( $key ) > $max ) {
            $max = length( $key );
        }
    }
    foreach my $key ( sort keys %$vars ) {
        my $values = $vars->{$key};
        printf "%-" . $max . "s: %s\n", $key, _var2string( $values->[0] );
        for( my $i=1 ; $i<@$values ; ++$i ) {
            printf "%" . $max . "s  %s\n", '(overridden)', _var2string( $values->[$i] );
        }
    }
    exit 0;
}

my @allTaskNames = ();
foreach my $taskName ( @taskNames ) {
    if( exists( $shortcuts->{$taskName} )) {
        if( ref( $shortcuts->{$taskName} ) eq 'ARRAY' ) {
            my @subTaskNames = ();

            $settings->addArgumentsFrom( $shortcuts->{$taskName}, \@subTaskNames );

            foreach my $subTaskName ( @subTaskNames ) {
                $subTaskName = _checkCleanLoadTask( $subTaskName );
                push @allTaskNames, $subTaskName;

            }

        } else {
            $taskName = $shortcuts->{$taskName};
            $taskName = _checkCleanLoadTask( $taskName );

            push @allTaskNames, $taskName;
        }
    } else {
        $taskName = _checkCleanLoadTask( $taskName );

        push @allTaskNames, $taskName;
    }
}

if( $dryRun ) {
    print join( '', map { "$_\n" } @allTaskNames );

} else {
    foreach my $taskName ( @allTaskNames ) {
        my $t = $taskName->new( '_settings' => $settings );
        unless( $t ) {
            fatal( "Cannot find or run task $taskName" );
        }

        UBOS::Logging::initialize( 'macrobuild', $taskName, $verbose, $logconf );

        my $run = new Macrobuild::TaskRun( $settings, undef, $interactive );

        trace( "About to run", ref( $t ));

        my $ret = $t->run( $run );
        if( $ret < 0 ) {
            error( "Aborting with error" );
            exit( $ret );
        }
    }
}

exit 0;

#####
sub _var2string {
    my $s = shift;

    if( !defined( $s )) {
        return '<undef>';
    }
    if( ref( $s ) eq 'ARRAY' ) {
        return '[ ' . join( ', ', map { _var2string( $_ ) } @$s ) . ' ]';
    }
    if( ref( $s ) eq 'HASH' ) {
        return '[ ' . join( ', ', map { "$_ => " . _var2string( $s->{$_} ) } sort keys %$s ) . ' ]';
    }
    return $s;
}

#####
sub _checkCleanLoadTask {
    my $taskName = shift;

    if( $taskName =~ m!::! ) {
        # Perl package name has been given as a task name
        eval "require $taskName" || fatal( 'Cannot load package', "$taskName\n", $@ );

    } else {
        my $fileName = $taskName;
        if( $fileName =~ m!^(.*)\.pm$! ) {
            $taskName = $1;
        } else {
            $fileName = "$fileName.pm";
        }
        eval "require '$fileName';" || fatal( 'Cannot read file', "$fileName\n", $@ );
        $taskName =~ s!/!::!g;
    }
    return $taskName;
}

#####
sub _determineEffectiveShortcuts {
    my @shortcutDefs = @_;

    # take what's in the first non-null element, and resolve further down the line if it says so
    my $first;
    while( !( $first = shift @shortcutDefs )) {
        # no op
    }

    my $ret = {};
    if( $first ) {
        foreach my $key ( keys %$first ) {
            my $value = $first->{$key};
            if( defined( $value )) {
                $ret->{$key} = $value;
            } else {
                # keep looking
                foreach my $later ( @shortcutDefs ) {
                    if( exists( $later->{$key} )) {
                        if( $later->{$key} ) {
                            $ret->{$key} = $later->{$key};
                            last;
                        } # else keep looking
                    } else {
                        last;
                    }
                }
            }
        }
    }

    return $ret;
}

#####
sub synopsisHelpQuit {
    my $long   = shift;

    if( $long ) {
print <<END;
Run a build task.

END
    } else {
        print "Synopsis:\n";
    }
    print "    $0 [ --dry-run ][ -n ][ --verbose ][ --logConfFile <log4perlconf> ][ --<key> <value> ]... <taskname> ...\n";
    if( $long ) {
        print <<END;
        Run the named build tasks. Optionally, specify parameters as key-value pairs that will be
        available to the tasks, and a log configuration file.
        If --try-run or -n is given, do not execute.

END
    }
    print "    $0 --list-shortcuts\n";
    if( $long ) {
        print <<END;
        List the tasks shortcuts that have been defined in the settings.pl or local.pl file. If
        no such shortcuts have been defined, you need to specify the full qualified name of the
        task, such as Macrobuild::UBOS::Hello

END
    }
    print "    $0 --print-vars\n";
    if( $long ) {
        print <<END;
        Print the known variables that can be used in build tasks.

END
    }
    print "    $0 --help\n";
    if( $long ) {
        print <<END;
        Display help text.

END
    }

    exit 0;
}

1;
